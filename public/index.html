<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>B-roll Finder</title>
  <style>
    :root {
      color-scheme: light;
      --ink: #1c2534;
      --muted: #4b5567;
      --bg: #f4f6fb;
      --card: #ffffff;
      --accent: #2563eb;
      --accent-soft: #dbeafe;
      --border: #d6dae5;
      --success: #15803d;
      --warning: #b91c1c;
      font-family: "Inter", ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans", Arial, sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--ink);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      padding: 32px 16px 64px;
    }

    .app-shell {
      width: min(1200px, 100%);
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    header {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    header h1 {
      font-size: 1.9rem;
      margin: 0;
      letter-spacing: -0.01em;
    }

    header p {
      margin: 0;
      color: var(--muted);
    }

    form {
      display: grid;
      gap: 12px;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 18px;
      padding: 18px;
      box-shadow: 0 12px 30px -24px #1c253440;
    }

    .form-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(210px, 1fr));
      gap: 14px;
    }

    label {
      display: grid;
      gap: 6px;
      font-size: 0.82rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      color: var(--muted);
    }

    input[type="text"],
    input[type="number"],
    select {
      appearance: none;
      width: 100%;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: #fdfdff;
      font: 500 0.95rem/1.4 var(--font, inherit);
      color: inherit;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    input:focus,
    select:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px var(--accent-soft);
    }

    .actions {
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 12px;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 10px 18px;
      font-weight: 600;
      font-size: 0.95rem;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.2s ease, background 0.2s ease;
    }

    button.primary {
      background: var(--accent);
      color: #fff;
      box-shadow: 0 10px 18px -12px var(--accent);
    }

    button.primary:disabled,
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }

    button.secondary {
      background: #e3e8f6;
      color: var(--ink);
    }

    button:not(:disabled):hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 24px -16px #1c2534aa;
    }

    .filters-line {
      font-size: 0.9rem;
      color: var(--muted);
      padding-left: 4px;
    }

    main {
      display: grid;
      grid-template-columns: minmax(0, 1fr) minmax(260px, 320px);
      gap: 20px;
      align-items: start;
    }

    .results-panel {
      display: flex;
      flex-direction: column;
      gap: 18px;
      min-width: 0;
    }

    .results-header {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .results-header h2 {
      margin: 0;
      font-size: 1.1rem;
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      color: var(--muted);
    }

    .chips {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .chip {
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #f9fbff;
      font-size: 0.85rem;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
    }

    .chip[data-active="true"] {
      background: var(--accent);
      color: #fff;
      border-color: transparent;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
      gap: 16px;
    }

    .clip-card {
      position: relative;
      display: flex;
      flex-direction: column;
      gap: 10px;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 18px;
      padding: 14px;
      box-shadow: 0 18px 38px -32px #1c253460;
    }

    .clip-media {
      position: relative;
      border-radius: 14px;
      overflow: hidden;
      aspect-ratio: 16 / 9;
      background: #121826;
      cursor: pointer;
    }

    .clip-media img,
    .clip-media video {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      transition: opacity 0.3s ease;
    }

    .clip-media video {
      opacity: 0;
      pointer-events: none;
    }

    .clip-media[data-playing="true"] video {
      opacity: 1;
    }

    .clip-meta {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 0.85rem;
    }

    .badge-row {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }

    .badge {
      padding: 4px 8px;
      border-radius: 999px;
      background: #eef2ff;
      color: #3b4a74;
      font-size: 0.75rem;
      font-weight: 600;
    }

    .tag-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      color: var(--muted);
      font-size: 0.78rem;
    }

    .tag-list span {
      background: #f1f5f9;
      padding: 2px 6px;
      border-radius: 6px;
    }

    .card-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.85rem;
    }

    .card-footer label {
      text-transform: none;
      font-weight: 500;
      letter-spacing: normal;
      color: inherit;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .card-footer input[type="checkbox"] {
      width: 18px;
      height: 18px;
      accent-color: var(--accent);
    }

    .empty-state,
    .status-line {
      text-align: center;
      color: var(--muted);
      font-size: 0.95rem;
    }

    .status-line {
      display: none;
    }

    .status-line[data-visible="true"] {
      display: block;
    }

    .bin-panel {
      position: sticky;
      top: 24px;
      display: flex;
      flex-direction: column;
      gap: 14px;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 20px;
      box-shadow: 0 20px 46px -34px #1c253470;
      max-height: calc(100vh - 48px);
      overflow-y: auto;
    }

    .bin-panel h2 {
      margin: 0;
      font-size: 1.1rem;
    }

    .bin-summary {
      color: var(--muted);
      font-size: 0.9rem;
    }

    .bin-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .bin-item {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px;
      display: grid;
      gap: 4px;
      background: #f8faff;
    }

    .bin-item button {
      justify-self: start;
      background: transparent;
      color: var(--accent);
      padding: 0;
      border-radius: 6px;
      font-size: 0.85rem;
      box-shadow: none;
    }

    .bin-item button:hover {
      text-decoration: underline;
      transform: none;
    }

    pre.manifest-output {
      background: #0f172a;
      color: #e2e8f0;
      border-radius: 16px;
      padding: 16px;
      max-height: 200px;
      overflow: auto;
      font-size: 0.82rem;
    }

    .export-result {
      display: none;
      font-size: 0.9rem;
    }

    .export-result[data-visible="true"] {
      display: block;
    }

    .export-result a {
      color: var(--accent);
      font-weight: 600;
      text-decoration: none;
    }

    .toast {
      position: fixed;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%) translateY(120%);
      background: #0f172a;
      color: #f8fafc;
      padding: 12px 18px;
      border-radius: 999px;
      box-shadow: 0 20px 32px -24px #0f172aaa;
      transition: transform 0.4s ease;
      z-index: 1000;
      pointer-events: none;
    }

    .toast[data-visible="true"] {
      transform: translateX(-50%) translateY(0);
    }

    @media (max-width: 1080px) {
      main {
        grid-template-columns: 1fr;
      }

      .bin-panel {
        position: static;
        max-height: none;
      }
    }

    @media (max-width: 640px) {
      body {
        padding: 24px 12px 48px;
      }

      form {
        padding: 16px;
      }

      .clip-card {
        padding: 12px;
      }
    }
  </style>
</head>
<body>
  <div class="app-shell">
    <header>
      <h1>B-roll Finder</h1>
      <p>Search the clip vault, curate a bin, and export ready-to-cut sub-clips.</p>
    </header>

    <form id="search-form" novalidate>
      <div class="form-grid">
        <label>
          Query
          <input type="text" name="query" placeholder="Describe the shot, action, or objects" required />
        </label>
        <label>
          Min duration (sec)
          <input type="number" name="minDurationSec" min="1" max="60" value="3" />
        </label>
        <label>
          Max duration (sec)
          <input type="number" name="maxDurationSec" min="1" max="120" value="12" />
        </label>
        <label>
          Aspect ratio
          <select name="aspect">
            <option value="16:9">16:9</option>
            <option value="9:16">9:16</option>
            <option value="1:1">1:1</option>
          </select>
        </label>
        <label>
          Tags
          <input type="text" name="tags" placeholder="comma-separated tags, e.g., coffee,hands,no-faces" />
        </label>
      </div>
      <div class="actions">
        <span class="status-line" id="status-line" role="status" aria-live="polite"></span>
        <button class="primary" type="submit" id="search-button">Search</button>
      </div>
    </form>

    <div class="filters-line" id="filters-line"></div>

    <main>
      <section class="results-panel" aria-live="polite">
        <div class="results-header">
          <h2>Results <span id="result-count"></span></h2>
          <div class="chips" id="tag-chips" aria-label="Filter by tag"></div>
        </div>
        <p class="empty-state" id="empty-state">No matches yet. Try a simpler query or different duration range.</p>
        <div class="grid" id="results-grid" role="list"></div>
      </section>

      <aside class="bin-panel">
        <h2>Bin</h2>
        <div class="bin-summary" id="bin-summary">No clips selected.</div>
        <ul class="bin-list" id="bin-list"></ul>
        <div class="actions" style="justify-content: flex-start;">
          <button class="secondary" type="button" id="build-manifest">Build manifest</button>
          <button class="primary" type="button" id="export-button" disabled>Export sub-clips</button>
        </div>
        <pre class="manifest-output" id="manifest-output" aria-live="polite" aria-label="Manifest JSON"></pre>
        <div class="export-result" id="export-result"></div>
      </aside>
    </main>
  </div>

  <div class="toast" id="toast" role="status" aria-live="polite"></div>

  <script>
    const BASE_URL = 'https://replace-with-service-host';
    const STORAGE_KEYS = {
      search: 'broll:last-search',
      results: 'broll:last-results',
      bin: 'broll:bin'
    };

    const state = {
      results: [],
      filters: new Set(),
      bin: []
    };

    const form = document.getElementById('search-form');
    const searchButton = document.getElementById('search-button');
    const statusLine = document.getElementById('status-line');
    const filtersLine = document.getElementById('filters-line');
    const resultCount = document.getElementById('result-count');
    const tagChips = document.getElementById('tag-chips');
    const resultsGrid = document.getElementById('results-grid');
    const emptyState = document.getElementById('empty-state');
    const binSummary = document.getElementById('bin-summary');
    const binList = document.getElementById('bin-list');
    const buildManifestButton = document.getElementById('build-manifest');
    const exportButton = document.getElementById('export-button');
    const manifestOutput = document.getElementById('manifest-output');
    const exportResult = document.getElementById('export-result');
    const toast = document.getElementById('toast');

    const checkboxRegistry = new Map();

    restoreSession();
    renderBin();
    renderResults();

    form.addEventListener('submit', async (event) => {
      event.preventDefault();
      await runSearch();
    });

    buildManifestButton.addEventListener('click', () => {
      const manifest = buildManifest();
      manifestOutput.textContent = JSON.stringify(manifest, null, 2);
      if (!manifest.clips.length) {
        showToast('Select clips to build a manifest.');
      } else {
        showToast('Manifest ready.');
      }
    });

    exportButton.addEventListener('click', async () => {
      const manifest = buildManifest();
      if (!manifest.clips.length) return;

      exportButton.disabled = true;
      exportButton.textContent = 'Exporting…';
      exportResult.dataset.visible = 'false';

      try {
        const response = await fetch(`${BASE_URL}/export_clips`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(manifest)
        });

        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(errorText || `Export failed (${response.status})`);
        }

        const payload = await response.json();
        exportResult.innerHTML = `Export ready — <a href="${payload.downloadUrl}" target="_blank" rel="noopener">Download ZIP</a>`;
        exportResult.dataset.visible = 'true';
        showToast('Export ready');
      } catch (error) {
        console.error(error);
        showToast(error?.message || 'Export failed', true);
      } finally {
        exportButton.disabled = state.bin.length === 0;
        exportButton.textContent = 'Export sub-clips';
      }
    });

    tagChips.addEventListener('click', (event) => {
      const chip = event.target.closest('.chip');
      if (!chip) return;
      const tag = chip.dataset.tag;
      if (state.filters.has(tag)) {
        state.filters.delete(tag);
        chip.dataset.active = 'false';
      } else {
        state.filters.add(tag);
        chip.dataset.active = 'true';
      }
      renderResults();
    });

    function buildManifest() {
      return {
        clips: state.bin.map((clip) => ({
          id: clip.id,
          startMs: clip.startMs,
          endMs: clip.endMs
        }))
      };
    }

    function applyFilters(results) {
      if (!state.filters.size) return results;
      return results.filter((clip) => {
        const clipTags = new Set(clip.tags || []);
        for (const tag of state.filters) {
          if (!clipTags.has(tag)) return false;
        }
        return true;
      });
    }

    async function runSearch() {
      const formData = new FormData(form);
      const query = (formData.get('query') || '').toString().trim();
      const minDurationSec = Number(formData.get('minDurationSec')) || 0;
      const maxDurationSec = Number(formData.get('maxDurationSec')) || 0;
      const aspect = (formData.get('aspect') || '').toString();
      const rawTags = (formData.get('tags') || '').toString();
      const tags = rawTags.split(',').map((tag) => tag.trim()).filter(Boolean).join(',');

      if (!query) {
        showToast('Enter a query to search.', true);
        return;
      }

      statusLine.dataset.visible = 'true';
      statusLine.textContent = 'Searching clips…';
      searchButton.disabled = true;

      const params = new URLSearchParams({
        query,
        min: String(minDurationSec || ''),
        max: String(maxDurationSec || ''),
        aspect
      });
      if (tags) params.set('tags', tags);

      try {
        const url = `${BASE_URL}/search_clips?${params.toString()}`;
        const response = await fetch(url);
        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(errorText || `Search failed (${response.status})`);
        }
        const data = await response.json();
        state.results = Array.isArray(data.results) ? data.results : [];
        state.filters.clear();
        persistSearch({ query, minDurationSec, maxDurationSec, aspect, tags: rawTags }, state.results);
        renderResults();
        updateFilterLine({ query, minDurationSec, maxDurationSec, aspect, tags: rawTags });
      } catch (error) {
        console.error(error);
        showToast(error?.message || 'Search failed', true);
      } finally {
        statusLine.dataset.visible = 'false';
        statusLine.textContent = '';
        searchButton.disabled = false;
      }
    }

    function renderResults() {
      resultsGrid.innerHTML = '';
      checkboxRegistry.clear();

      const filteredResults = applyFilters(state.results);
      const total = state.results.length;
      const visible = filteredResults.length;
      resultCount.textContent = total ? `${visible} of ${total}` : '0';

      const tags = new Set();
      state.results.forEach((clip) => (clip.tags || []).forEach((tag) => tags.add(tag)));
      renderTagChips(Array.from(tags).sort((a, b) => a.localeCompare(b)));

      if (!total) {
        emptyState.style.display = 'block';
        return;
      }

      emptyState.style.display = 'none';

      if (!visible) {
        const message = document.createElement('p');
        message.className = 'empty-state';
        message.textContent = 'No results match the selected tag filters.';
        resultsGrid.appendChild(message);
        return;
      }

      for (const clip of filteredResults) {
        const card = createClipCard(clip);
        resultsGrid.appendChild(card);
      }
    }

    function createClipCard(clip) {
      const card = document.createElement('article');
      card.className = 'clip-card';
      card.setAttribute('role', 'listitem');

      const media = document.createElement('div');
      media.className = 'clip-media';
      const image = document.createElement('img');
      image.loading = 'lazy';
      image.src = clip.thumbUrl;
      image.alt = clip.title ? `Thumbnail for ${clip.title}` : 'Clip thumbnail';
      const video = document.createElement('video');
      video.src = clip.previewUrl;
      video.muted = true;
      video.loop = true;
      video.playsInline = true;
      video.preload = 'none';

      media.append(image, video);

      const togglePlayback = () => {
        const playing = media.dataset.playing === 'true';
        if (playing) {
          media.dataset.playing = 'false';
          video.pause();
          video.currentTime = 0;
        } else {
          media.dataset.playing = 'true';
          video.play().catch(() => {
            media.dataset.playing = 'false';
          });
        }
      };

      media.addEventListener('mouseenter', () => {
        media.dataset.playing = 'true';
        video.play().catch(() => {
          media.dataset.playing = 'false';
        });
      });
      media.addEventListener('mouseleave', () => {
        media.dataset.playing = 'false';
        video.pause();
        video.currentTime = 0;
      });
      media.addEventListener('click', togglePlayback);

      const meta = document.createElement('div');
      meta.className = 'clip-meta';
      const title = document.createElement('strong');
      title.textContent = clip.title || clip.id;
      const duration = document.createElement('div');
      duration.textContent = `${clip.durationSec.toFixed(1)} sec`;

      const badgeRow = document.createElement('div');
      badgeRow.className = 'badge-row';
      const aspectBadge = document.createElement('span');
      aspectBadge.className = 'badge';
      aspectBadge.textContent = clip.aspect;
      const fpsBadge = document.createElement('span');
      fpsBadge.className = 'badge';
      fpsBadge.textContent = `${clip.fps} fps`;
      badgeRow.append(aspectBadge, fpsBadge);

      const tags = document.createElement('div');
      tags.className = 'tag-list';
      (clip.tags || []).forEach((tag) => {
        const span = document.createElement('span');
        span.textContent = tag;
        tags.appendChild(span);
      });

      meta.append(title, duration, badgeRow, tags);

      const footer = document.createElement('div');
      footer.className = 'card-footer';
      const checkboxLabel = document.createElement('label');
      checkboxLabel.textContent = 'Add to bin';
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.dataset.clipId = clip.id;
      checkbox.checked = state.bin.some((item) => item.id === clip.id);
      checkbox.addEventListener('change', () => {
        toggleBin(clip, checkbox.checked);
      });
      checkboxLabel.prepend(checkbox);

      const path = document.createElement('span');
      path.textContent = clip.path;
      path.style.fontSize = '0.75rem';
      path.style.color = 'var(--muted)';
      path.style.maxWidth = '60%';
      path.style.whiteSpace = 'nowrap';
      path.style.textOverflow = 'ellipsis';
      path.style.overflow = 'hidden';

      footer.append(path, checkboxLabel);

      card.append(media, meta, footer);
      checkboxRegistry.set(clip.id, checkbox);
      return card;
    }

    function toggleBin(clip, shouldAdd) {
      const existingIndex = state.bin.findIndex((item) => item.id === clip.id);
      if (shouldAdd && existingIndex === -1) {
        state.bin.push({ id: clip.id, startMs: clip.startMs, endMs: clip.endMs, title: clip.title, durationSec: clip.durationSec });
      } else if (!shouldAdd && existingIndex !== -1) {
        state.bin.splice(existingIndex, 1);
      }
      persistBin();
      renderBin();
    }

    function renderBin() {
      binList.innerHTML = '';
      if (!state.bin.length) {
        binSummary.textContent = 'No clips selected.';
        exportButton.disabled = true;
        manifestOutput.textContent = '';
        return;
      }

      const totalDurationMs = state.bin.reduce((sum, clip) => sum + Math.max(0, clip.endMs - clip.startMs), 0);
      const seconds = totalDurationMs / 1000;
      binSummary.textContent = `${state.bin.length} clip${state.bin.length === 1 ? '' : 's'} · ${seconds.toFixed(1)} sec total`;
      exportButton.disabled = false;

      for (const clip of state.bin) {
        const item = document.createElement('li');
        item.className = 'bin-item';
        const title = document.createElement('strong');
        title.textContent = clip.title || clip.id;
        const timing = document.createElement('span');
        timing.textContent = `${clip.startMs}ms → ${clip.endMs}ms`;
        const remove = document.createElement('button');
        remove.type = 'button';
        remove.textContent = 'Remove';
        remove.addEventListener('click', () => {
          toggleBin(clip, false);
          const checkbox = checkboxRegistry.get(clip.id);
          if (checkbox) checkbox.checked = false;
        });
        item.append(title, timing, remove);
        binList.appendChild(item);
      }
    }

    function renderTagChips(tags) {
      tagChips.innerHTML = '';
      tags.forEach((tag) => {
        const chip = document.createElement('button');
        chip.type = 'button';
        chip.className = 'chip';
        chip.dataset.tag = tag;
        chip.dataset.active = state.filters.has(tag) ? 'true' : 'false';
        chip.textContent = tag;
        tagChips.appendChild(chip);
      });
    }

    function updateFilterLine({ query, minDurationSec, maxDurationSec, aspect, tags }) {
      const pieces = [];
      if (query) pieces.push(`Query “${query}”`);
      if (aspect) pieces.push(`Aspect ${aspect}`);
      if (minDurationSec || maxDurationSec) {
        const minText = minDurationSec ? `${minDurationSec}s` : '0s';
        const maxText = maxDurationSec ? `${maxDurationSec}s` : '∞';
        pieces.push(`Duration ${minText} – ${maxText}`);
      }
      if (tags && tags.trim()) {
        pieces.push(`Tags ${tags.split(',').map((tag) => tag.trim()).filter(Boolean).join(', ')}`);
      }
      filtersLine.textContent = pieces.length ? `Current filters: ${pieces.join(' · ')}` : '';
    }

    function persistSearch(values, results) {
      try {
        sessionStorage.setItem(STORAGE_KEYS.search, JSON.stringify(values));
        sessionStorage.setItem(STORAGE_KEYS.results, JSON.stringify(results));
      } catch (error) {
        console.warn('Unable to persist search state', error);
      }
    }

    function persistBin() {
      try {
        sessionStorage.setItem(STORAGE_KEYS.bin, JSON.stringify(state.bin));
      } catch (error) {
        console.warn('Unable to persist bin state', error);
      }
    }

    function restoreSession() {
      try {
        const savedSearch = sessionStorage.getItem(STORAGE_KEYS.search);
        if (savedSearch) {
          const values = JSON.parse(savedSearch);
          Object.entries(values).forEach(([key, value]) => {
            const input = form.elements.namedItem(key);
            if (input && typeof value === 'string') {
              input.value = value;
            } else if (input && typeof value === 'number') {
              input.value = String(value);
            }
          });
          updateFilterLine(values);
        }

        const savedResults = sessionStorage.getItem(STORAGE_KEYS.results);
        if (savedResults) {
          state.results = JSON.parse(savedResults);
        }

        const savedBin = sessionStorage.getItem(STORAGE_KEYS.bin);
        if (savedBin) {
          state.bin = JSON.parse(savedBin);
        }
      } catch (error) {
        console.warn('Unable to restore previous session', error);
      }
    }

    let toastTimer;
    function showToast(message, isError = false) {
      toast.textContent = message;
      toast.style.background = isError ? '#7f1d1d' : '#0f172a';
      toast.dataset.visible = 'true';
      clearTimeout(toastTimer);
      toastTimer = setTimeout(() => {
        toast.dataset.visible = 'false';
      }, 3200);
    }
  </script>
</body>
</html>
